name: Test Shared Code

on:
  push:
    tags:
      - '*'   # any tag; we'll guard to main in the job

# Token permissions for OIDC
#permissions:
#   id-token: write
#   contents: write
#   actions: read
#   security-events: write

env:
  GH_RUNNER: "dtfsgitrunner"
  TEMPLATE_REPO_REF: "main"
  DOTNET_INSTALL_DIR: "~/.dotnet"
  SOLUTION_DIRECTORY: sample/src
  CONFIGURATION: Release
  DOTNET_CORE_VERSION: 9.0.x

# jobs:

# # .github/workflows/publish-nuget-to-artifactory.yml
# name: Publish NuGet to Artifactory (tags on main)

# on:
#   push:
#     tags:
#       - '*'   # we’ll guard to "main" in-job

# Token permissions for OIDC
#permissions:
#   id-token: write
#   contents: write
#   actions: read
#   security-events: write

env:
  GH_RUNNER: "dtfsgitrunner"
  TEMPLATE_REPO_REF: "main"
  DOTNET_INSTALL_DIR: "~/.dotnet"
  SOLUTION_DIRECTORY: sample/src
  CONFIGURATION: Release
  DOTNET_CORE_VERSION: 9.0.x

# jobs:

# # .github/workflows/publish-nuget-to-artifactory.yml
# name: Publish NuGet to Artifactory (tags on main)

# on:
#   push:
#     tags:
#       - '*'   # we’ll guard to "main" in-job

jobs:
  build-pack-publish:
    # runs-on: [self-hosted, dtfsgitrunner]
    runs-on: ubuntu-latest
    env:
      # (1) Artifactory V3 NuGet feed URL (local/virtual repo)
      NUGET_SOURCE_URL: https://YOUR-ARTIFACTORY/artifactory/api/nuget/v3/YOUR-REPO/index.json
      # (2) Optional path where packages are output
      PACK_OUTPUT: nuget-artifacts
      SOLUTION_FILE: shared-code/src/DTFS.Integration.Shared.sln

    env:
      TARGET_DIR: path/to/your/folder   # <<< change this

    steps:
      - name: Check out (full history + tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-depth: 0
          fetch-tags: true

      - name: Ensure origin/main is available
        run: git fetch origin +refs/heads/main:refs/remotes/origin/main --prune

      - name: Proceed only if tag commit is on main
        id: guard
        shell: bash
        run: |
          set -euo pipefail
          TAG_SHA="$(git rev-list -n 1 "$GITHUB_REF")"
          if git merge-base --is-ancestor "$TAG_SHA" origin/main; then
            echo "on_main=true" >> "$GITHUB_OUTPUT"
            echo "Tag is on main ✔"
          else
            echo "on_main=false" >> "$GITHUB_OUTPUT"
            echo "Tag is NOT on main ✖"
          fi

    #   - name: Stop if not on main
    #     if: steps.guard.outputs.on_main != 'true'
    #     run: |
    #       echo "Exiting (tag is not on main)."
    #       exit 0

      - name: Stop if not on main
        if: steps.guard.outputs.on_main != 'true'
        run: |
          echo "Exiting (tag is not on main). Not actually for now while testing"

      - name: Determine current & previous tag
        id: tags
        shell: bash
        run: |
          set -euo pipefail
          echo "current=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"

          # Make sure tags are present locally
          git fetch --force --tags

          # Previous tag by creation date (immediately before the current tag)
          PREV_TAG="$(git tag --sort=-creatordate | awk -v cur="$GITHUB_REF_NAME" '$0==cur{getline; print; exit}')"

          # Fallback: second-most-recent tag if the above didn't find one
          if [ -z "$PREV_TAG" ]; then
            PREV_TAG="$(git describe --abbrev=0 --tags "$(git rev-list --tags --skip=1 --max-count=1)" || true)"
          fi

          echo "previous=${PREV_TAG}" >> "$GITHUB_OUTPUT"
          echo "Previous tag: ${PREV_TAG:-<none>}"

      - name: Set up .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'
      # setup-dotnet prepares the CLI for restore/build/pack/push. :contentReference[oaicite:1]{index=1}


        #TAG="${GITHUB_REF_NAME}"
      - name: Derive versions from tag
        id: ver
        shell: bash
        run: |
          set -euo pipefail
          # Short tag name, e.g. v1.2.3-beta.4
          TAG="v0.0.1"
          # Strip optional leading 'v'
          VERSION="${TAG#v}"

          # NUMERIC (strip any -prerelease) e.g. 1.2.3
          NUMERIC="${VERSION%%-*}"

          # AssemblyVersion (major.minor.0.0) — stable to reduce binding churn
          MAJOR="${NUMERIC%%.*}"
          REST="${NUMERIC#*.}"
          MINOR="${REST%%.*}"
          ASSEMBLY_VERSION="${MAJOR}.${MINOR}.0.0"

          # FileVersion must be numeric only (no suffix). Use full numeric SemVer (1.2.3)
          FILE_VERSION="${NUMERIC}"

          # InformationalVersion can include the full SemVer (incl. suffix)
          INFO_VERSION="${VERSION}"

          echo "package_version=${VERSION}"           >> "$GITHUB_OUTPUT"
          echo "assembly_version=${ASSEMBLY_VERSION}" >> "$GITHUB_OUTPUT"
          echo "file_version=${FILE_VERSION}"         >> "$GITHUB_OUTPUT"
          echo "info_version=${INFO_VERSION}"         >> "$GITHUB_OUTPUT"

          echo "Computed:"
          echo "  Package/Version:     $VERSION"
          echo "  AssemblyVersion:     $ASSEMBLY_VERSION"
          echo "  FileVersion:         $FILE_VERSION"
          echo "  InformationalVersion:$INFO_VERSION"
      # GITHUB_REF_NAME exposes the short tag like "v1.2.3"; .NET lets you set Version/AssemblyVersion/FileVersion/InformationalVersion via MSBuild properties. :contentReference[oaicite:2]{index=2}

      - name: Restore
        run: dotnet restore ${{ env.SOLUTION_FILE }}

      - name: Build (stamp versions)
        run: |
          dotnet build ${{ env.SOLUTION_FILE }} --configuration Release \
            -p:ContinuousIntegrationBuild=true \
            -p:Version=${{ steps.ver.outputs.package_version }} \
            -p:PackageVersion=${{ steps.ver.outputs.package_version }} \
            -p:AssemblyVersion=${{ steps.ver.outputs.assembly_version }} \
            -p:FileVersion=${{ steps.ver.outputs.file_version }} \
            -p:InformationalVersion="${{ steps.ver.outputs.info_version }}"
      # Version/PackageVersion flow into packing; assembly/file versions become assembly attributes in SDK-style projects. :contentReference[oaicite:3]{index=3}

      - name: Pack
        run: |
          dotnet pack ${{ env.SOLUTION_FILE }} --configuration Release --no-build \
            -p:PackageVersion=${{ steps.ver.outputs.package_version }} \
            -o "$PACK_OUTPUT"

      - name: Publish NuGet Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: "Nuget Packages"
          path: ${{ env.PACK_OUTPUT }}
          include-hidden-files: true

      - name: Register Nuget Source
        run: |
          echo "Running task because ${{ env.TARGET_DIR }} changed."
          # TODO: your commands go here (build, publish, deploy, etc.)

      - name: Skip message
        if: steps.diff.outputs.changed == 'false'
        run: echo "Folder unchanged; skipping task."
