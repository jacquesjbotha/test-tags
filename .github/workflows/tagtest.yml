name: Test Shared Code

on:
  push:
    tags:
      - '*'   # any tag; we'll guard to main in the job

# Token permissions for OIDC
#permissions:
#   id-token: write
#   contents: write
#   actions: read
#   security-events: write

env:
  GH_RUNNER: "dtfsgitrunner"
  TEMPLATE_REPO_REF: "main"
  DOTNET_INSTALL_DIR: "~/.dotnet"
  SOLUTION_DIRECTORY: sample/src
  CONFIGURATION: Release
  DOTNET_CORE_VERSION: 9.0.x

# jobs:

# # .github/workflows/publish-nuget-to-artifactory.yml
# name: Publish NuGet to Artifactory (tags on main)

# on:
#   push:
#     tags:
#       - '*'   # we’ll guard to "main" in-job

# Token permissions for OIDC
#permissions:
#   id-token: write
#   contents: write
#   actions: read
#   security-events: write

# jobs:

# # .github/workflows/publish-nuget-to-artifactory.yml
# name: Publish NuGet to Artifactory (tags on main)

# on:
#   push:
#     tags:
#       - '*'   # we’ll guard to "main" in-job

jobs:
  build-pack-publish:
    # runs-on: [self-hosted, dtfsgitrunner]
    runs-on: ubuntu-latest
    env:
      # (1) Artifactory V3 NuGet feed URL (local/virtual repo)
      NUGET_SOURCE_URL: https://YOUR-ARTIFACTORY/artifactory/api/nuget/v3/YOUR-REPO/index.json
      # (2) Optional path where packages are output
      PACK_OUTPUT: nuget-artifacts
      SOLUTION_FILE: shared-code/src/DTFS.Integration.Shared.sln

    steps:
      - name: Check out (full history + tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Ensure origin/main is available
        run: git fetch origin +refs/heads/main:refs/remotes/origin/main --prune

      - name: Proceed only if tag commit is on main
        id: guard
        shell: bash
        run: |
          set -euo pipefail
          TAG_SHA="$(git rev-list -n 1 "$GITHUB_REF")"
          if git merge-base --is-ancestor "$TAG_SHA" origin/main; then
            echo "on_main=true" >> "$GITHUB_OUTPUT"
            echo "Tag is on main ✔"
          else
            echo "on_main=false" >> "$GITHUB_OUTPUT"
            echo "Tag is NOT on main ✖"
          fi

      - name: Stop if not on main
        if: steps.guard.outputs.on_main != 'true'
        run: |
          echo "Exiting (tag is not on main)."
          exit 0

      # - name: Stop if not on main
      #   if: steps.guard.outputs.on_main != 'true'
      #   run: |
      #     echo "Exiting (tag is not on main). Not actually for now while testing"

      - name: Determine current & previous tag
        id: tags
        shell: bash
        run: |
          set -euo pipefail
          echo "current=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"

          # Make sure tags are present locally
          git fetch --force --tags

          # Previous tag by creation date (immediately before the current tag)
          PREV_TAG="$(git tag --sort=-creatordate | awk -v cur="$GITHUB_REF_NAME" '$0==cur{getline; print; exit}')"

          # Fallback: second-most-recent tag if the above didn't find one
          if [ -z "$PREV_TAG" ]; then
            PREV_TAG="$(git describe --abbrev=0 --tags "$(git rev-list --tags --skip=1 --max-count=1)" || true)"
          fi

          echo "previous=${PREV_TAG}" >> "$GITHUB_OUTPUT"
          echo "Previous tag: ${PREV_TAG:-<none>}"

      - name: Set up .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'
      # setup-dotnet prepares the CLI for restore/build/pack/push. :contentReference[oaicite:1]{index=1}


        #TAG="${GITHUB_REF_NAME}"
      - name: Derive versions from tag
        id: ver
        shell: bash
        run: |
          set -euo pipefail
          # Short tag name, e.g. v1.2.3-beta.4
          TAG="${GITHUB_REF_NAME}"
          # Strip optional leading 'v'
          VERSION="${TAG#v}"

          # NUMERIC (strip any -prerelease) e.g. 1.2.3
          NUMERIC="${VERSION%%-*}"

          # AssemblyVersion (major.minor.0.0) — stable to reduce binding churn
          MAJOR="${NUMERIC%%.*}"
          REST="${NUMERIC#*.}"
          MINOR="${REST%%.*}"
          ASSEMBLY_VERSION="${MAJOR}.${MINOR}.0.0"

          # FileVersion must be numeric only (no suffix). Use full numeric SemVer (1.2.3)
          FILE_VERSION="${NUMERIC}"

          # InformationalVersion can include the full SemVer (incl. suffix)
          INFO_VERSION="${VERSION}"

          echo "package_version=${VERSION}"           >> "$GITHUB_OUTPUT"
          echo "assembly_version=${ASSEMBLY_VERSION}" >> "$GITHUB_OUTPUT"
          echo "file_version=${FILE_VERSION}"         >> "$GITHUB_OUTPUT"
          echo "info_version=${INFO_VERSION}"         >> "$GITHUB_OUTPUT"

          echo "Computed:"
          echo "  Package/Version:     $VERSION"
          echo "  AssemblyVersion:     $ASSEMBLY_VERSION"
          echo "  FileVersion:         $FILE_VERSION"
          echo "  InformationalVersion:$INFO_VERSION"
      # GITHUB_REF_NAME exposes the short tag like "v1.2.3"; .NET lets you set Version/AssemblyVersion/FileVersion/InformationalVersion via MSBuild properties. :contentReference[oaicite:2]{index=2}

      - name: Restore
        run: dotnet restore ${{ env.SOLUTION_FILE }}

      - name: Build (stamp versions)
        run: |
          dotnet build ${{ env.SOLUTION_FILE }} --configuration Release \
            -p:ContinuousIntegrationBuild=true \
            -p:Version=${{ steps.ver.outputs.package_version }} \
            -p:PackageVersion=${{ steps.ver.outputs.package_version }} \
            -p:AssemblyVersion=${{ steps.ver.outputs.assembly_version }} \
            -p:FileVersion=${{ steps.ver.outputs.file_version }} \
            -p:InformationalVersion="${{ steps.ver.outputs.info_version }}"
      # Version/PackageVersion flow into packing; assembly/file versions become assembly attributes in SDK-style projects. :contentReference[oaicite:3]{index=3}

      - name: Pack
        run: |
          dotnet pack ${{ env.SOLUTION_FILE }} --configuration Release --no-build \
            -p:PackageVersion=${{ steps.ver.outputs.package_version }} \
            -o "$PACK_OUTPUT"

      - name: Publish NuGet Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: "Nuget Packages"
          path: ${{ env.PACK_OUTPUT }}
          include-hidden-files: true

     #library-one
      - name: Publish DTFS.Integration.Shared NuGet to Artifactory
        uses: ./.github/actions/publish-nuget-to-artifactory
        with:
          package-name: "library-one"
          folder-path: "tag-solution/library-one"
          api_key: "${{ secrets.ARTIFACTORY_API_USERNAME }}:${{ secrets.ARTIFACTORY_API_PASSWORD }}"
          previous_tag: "${{ steps.tags.outputs.previous }}"
          current_tag: "${{ steps.tags.outputs.current }}"
          
    #library-two
      - name: Publish DTFS.Integration.ExternalService.AzureKeyVault NuGet to Artifactory
        uses: ./.github/actions/publish-nuget-to-artifactory
        with:
          package-name: "library-two"
          folder-path: "tag-solution/library-two"
          api_key: "${{ secrets.ARTIFACTORY_API_USERNAME }}:${{ secrets.ARTIFACTORY_API_PASSWORD }}"
          previous_tag: "${{ steps.tags.outputs.previous }}"
          current_tag: "${{ steps.tags.outputs.current }}"